import { Callout } from 'nextra/components'

# Widgets mit State

<Callout>
  **Dauer:** 50 Minuten

  - `stateful` Widgets
  - Interaktion mit dem Zustand durch `setState`
  - Zust√§nde in `MyHomePage` und `TodoItem` implementieren

  **Ziel:** Widgets und State in Flutter verstehen
</Callout>

In Android hatten wir es mit Composables zu tun, in Flutter 
hei√üen die UI-Komponenten _Widgets_. W√§hrend in Compose einzelne
Composable-Funktionen mehrere Zustandsobjekte haben k√∂nnen, sind 
in Flutter die Widgets durch die Klassenhierarchie als Ganzes 
_stateless_ oder _stateful_. Trotz dieses Unterschieds gibt es viele 
Parallelen zwischen den beiden Frameworks. So f√ºhrt in beiden Ans√§tzen 
eine √Ñnderung des Zustands zu einer automatischen Aktualisierung des UIs.

## Stateful Widgets

Ein _stateful_ Widget ist eine Klasse, die von `StatefulWidget`
erbt und die Methode `createState` implementiert. Da ein stateful 
Widget selbst unver√§nderlich ist, speichert es ver√§nderlichen Zustand 
in einer separaten Klasse, die eine Subklasse von `State` ist. 
Diese `State`-Klasse wird im stateful Widget von der Methode 
`createState` zur√ºckgegeben. 

Wir k√∂nnen `TodoItem` als _stateful_ Widget implementieren:

**Achtung:** Wir k√∂nnen die `build`-Methode zun√§chst auskommentieren,
denn diese wird gleich in den `State` verschoben.

```dart
class TodoItem extends StatefulWidget {
  final String title;

  const TodoItem({super.key, required this.title});

  @override
  State<TodoItem> createState() => _TodoItemState();

  // Achtung: build-Methode geh√∂rt nun in den State!
}
```

Die Methode `createState` gibt ein Objekt zur√ºck, das den Zustand
des Widgets verwaltet. `StatefulWidget`s haben keine `build`-Methode; 
stattdessen wird ihre Benutzeroberfl√§che durch ihr `State`-Objekt 
aufgebaut. Dazu implementieren wir die Klasse `_TodoItemState`:

**Achtung:** Wir k√∂nnen die `build`-Methode nun in die 
`_TodoItemState`-Klasse verschieben, m√ºssen aber im `Text`-Widget
auf `widget.title` zugreifen (anstatt nur `title` wie zuvor).

```dart
class _TodoItemState extends State<TodoItem> {
  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: () {/* to be implemented */},
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 2.0),
        child: Row(
          children: [
            Checkbox(
              value: false,
              onChanged: (bool? value) {/* to be implemented */},
            ),
            Text(
              widget.title, // Achtung: Zugriff auf widget.title!
              style: const TextStyle(fontSize: 18),
            ),
          ],
        ),
      ),
    );
  }
}
```

Es ist eine Konvention, den Zustand in einer separaten Klasse zu
speichern, die mit einem Unterstrich beginnt und den Zusatz `State`
im Namen tr√§gt. In unserem Fall ist dies `_TodoItemState`. Der 
Zustand kann dann in der `State`-Klasse verwaltet werden.

## Interaktion mit dem Zustand durch `setState`

Das `State`-Objekt kann den Zustand des Widgets √§ndern, indem es
die Methode `setState` aufruft. Diese Methode nimmt eine Funktion
als Argument, die den neuen Zustand berechnet. In unserem Beispiel
wollen wir die Checkbox-Interaktion und das Antippen des Todos 
implementieren, um den Zustand des `TodoItem` zu √§ndern. 

Zun√§chst f√ºgen wir im `_TodoItemState` eine `_done`-Instanzvariable vom 
Typ `bool` hinzu, die den Zustand des Todos repr√§sentiert:

```dart
class _TodoItemState extends State<TodoItem> {
  bool _done = false; // Instanzvariable f√ºr den Zustand

  // restlicher Code bleibt unver√§ndert
}
```

Nun k√∂nnen wir die Handler f√ºr die Interaktionen implementieren,
dies sind `onTap` im `InkWell`-Widget und `onChanged` in der 
`Checkbox`. Beide Handler rufen die `setState`-Methode auf, um
den Zustand des Todos zu √§ndern:

```dart
setState(() {
  _done = !_done;
});
```

`setState` wird mit einer Funktion aufgerufen, die den neuen Zustand
berechnet. In unserem Fall wird `_done` auf den negierten Wert von
`_done` gesetzt. Das f√ºhrt dazu, dass der Zustand des Todos umgekehrt
wird, wenn die Checkbox angeklickt oder das Todo angetippt wird. 

Au√üerdem m√ºssen wir den aktuellen Wert der Checkbox (`value`) 
auf den des Zustands `_done` setzen. 

Hier der vollst√§ndige Code des `_TodoItemState`:

```dart
class _TodoItemState extends State<TodoItem> {
  bool _done = false; // Instanzvariable f√ºr den Zustand

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: () { // setState beim Antippen des Todos
        setState(() {
          _done = !_done; // Zustand umkehren
        });
      },
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 2.0),
        child: Row(
          children: [
            Checkbox(
              value: _done, // aktueller Zustand der Checkbox
              onChanged: (bool? value) {
                setState(() { // setState beim Klicken der Checkbox
                  _done = !_done; // Zustand umkehren
                });
              },
            ),
            Text(
              widget.title,
              style: const TextStyle(fontSize: 18),
            ),
          ],
        ),
      ),
    );
  }
}

```

Die √Ñnderung des Zustands bzw. der Aufruf von `setState` f√ºhrt
zu einer **automatischen** Neuzeichnung des UIs &mdash; ganz √§hnlich
wie in der nativen Android-Entwicklung mit Composables. 

Wir k√∂nnen den Zustand auch nutzen, um das Aussehen des Todos zu
√§ndern. Der Text wird durchgestrichen, wenn die Checkbox aktiviert ist:

```dart
Text(
  widget.title,
  style: TextStyle(
    fontSize: 18,
    decoration: _done ? TextDecoration.lineThrough : null,
  ),
),
```

<Callout type="info">
Manche Styles in Flutter erinnern an CSS:

- `fontSize` in Flutter wird in CSS als `font-size` geschrieben
- `TextDecoration.lineThrough` entspricht `text-decoration: line-through`
</Callout>

## Checkbox-Handler optimieren

Der Handler f√ºr die Checkbox kann noch folgenderma√üen optimiert 
werden, sodass er den an den Handler √ºbergebenen Wert von 
`value` direkt verwendet und ihn auf `null` √ºberpr√ºft:

```dart
Checkbox(
  value: _done,
  onChanged: (bool? value) {
    setState(() {
      _done = value ?? false;
    });
  },
),
```

Diese √Ñnderung ist nicht unbedingt n√∂tig, aber sie wurde als 
‚Äûidiomatische‚Äú L√∂sung von ChatGPT vorgeschlagen üòâ.

## `MyHomePage` in stateful Widget umwandeln

Wir wandeln nun `MyHomePage` in ein _stateful_ Widget um, weil 
wir dort die TodoListe als Zustand verwalten wollen.

<Callout>
In Project IDX und VS Code gibt es einen Shortcut, um ein Widget
in ein _stateful_ Widget umzuwandeln:

Cursor auf den Klassennamen setzen und dann `Ctrl + .` (Windows/Linux) 
oder `Cmd + . (Mac)` dr√ºcken, sodass passende Code-Aktionen angezeigt
werden. Dort `Convert to StatefulWidget` ausw√§hlen.

(Die klappt wohl auch in Android Studio mit `Alt + Enter`)
Android Studio / IntelliJ IDEA: Platzieren Sie den Cursor auf dem 
</Callout>

Der angepasste Code von `MyHomePage` und der neuen State-Klasse 
`_MyHomePageState` sieht dann so aus:

```dart
class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key});

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Todo-App'),
      ),
      body: const TodoList(),
      floatingActionButton: FloatingActionButton(
        onPressed: () => debugPrint('Todo hinzuf√ºgen'),
        tooltip: 'Todo hinzuf√ºgen',
        child: const Icon(Icons.add),
      ),
    );
  }
}
```

## TodoList-Zustand verwalten

Wir erweitern die neue State-Klasse `_MyHomePageState` mit einer
Instanzvariable `_todos` vom Typ `List<TodoItem>`, um die Todos
zu speichern und der `onPressed`-Handler des `FloatingActionButton`
f√ºgt ein neues Todo hinzu: 

```dart
class _MyHomePageState extends State<MyHomePage> {
  final List<TodoItem> _todos = []; // State f√ºr die Todo-Liste

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Todo-App'),
      ),
      body: const TodoList(),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          setState(() {
            _todos.add(const TodoItem(title: 'Neues Todo'));
          });
        },
        tooltip: 'Todo hinzuf√ºgen',
        child: const Icon(Icons.add),
      ),
    );
  }
}
```

Zun√§chst wird stets das gleiche Todo hinzugef√ºgt (`'Neues Todo'`),
aber sp√§ter verwenden wir eine Texteingabe, um den Titel des
neuen Todos zu bestimmen.

Eine Anpassung fehlt noch: Wir m√ºssen die `TodoList`-Instanz
mit den Todos aus `_todos` initialisieren. Dazu f√ºgen wir dem
Konstruktor von `TodoList` ein Argument `todos` hinzu. Es werden
folgende √Ñnderungen in `TodoList` vorgenommen:

```dart
class TodoList extends StatelessWidget {
  final List<TodoItem> todos;

  // der Konstruktor erh√§lt ein Argument f√ºr die Todos
  const TodoList({super.key, required this.todos});

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: todos.length,
      itemBuilder: (context, index) {
        return todos[index];
      },
    );
  }
}
```

Hier verwenden wir nun die `todos`-Instanzvariable im `ListView.builder`,
um die Todos zu rendern, was insbesondere dann ben√∂tigt wird, wenn
die Todo-Liste dynamisch ist. Mehr zu `ListView` in der Dokumentation:
[API-Docs zu `ListView`](https://api.flutter.dev/flutter/widgets/ListView-class.html)

Nun k√∂nnen wir in `_MyHomePageState` die `TodoList`-Instanz mit den
Todos initialisieren:

```dart
body: TodoList(todos: _todos),
```

Nochmals der gesamte Code von `_MyHomePageState`:

```dart
class _MyHomePageState extends State<MyHomePage> {
  final List<TodoItem> _todos = [];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Todo-App'),
      ),
      body: TodoList(todos: _todos), // Todos an TodoList √ºbergeben
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          setState(() {
            _todos.add(const TodoItem(title: 'Neues Todo'));
          });
        },
        tooltip: 'Todo hinzuf√ºgen',
        child: const Icon(Icons.add),
      ),
    );
  }
}
```

## `AlertDialog` f√ºr neue Todos

Zum Hinzuf√ºgen von neuen Todos k√∂nnen wir ein `AlertDialog` verwenden,
das eine Texteingabe f√ºr den Titel des neuen Todos enth√§lt. Dazu
m√ºssen wir den `onPressed`-Handler des `FloatingActionButton`s anpassen:

```dart
onPressed: () {
  showDialog(
    context: context,
    builder: (context) {
      final TextEditingController controller = TextEditingController();
      return AlertDialog(
        title: const Text('Neues Todo'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(hintText: 'Todo eingeben'),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Abbrechen'),
          ),
          TextButton(
            onPressed: () {
              if (controller.text.trim().isNotEmpty) {
                Navigator.of(context).pop(controller.text.trim());
              }
            },
            child: const Text('Hinzuf√ºgen'),
          ),
        ],
      );
    },
  ).then((value) { // F√ºgen wir das neue Todo dem State hinzu
    if (value != null && value is String) {
      setState(() {
        _todos.add(TodoItem(title: value));
      });
    }
  });
},
```

Wir f√ºhren zus√§tzliche Validierung durch, um leere Todos zu vermeiden.

Auch hier haben wir wieder eine starke √Ñhnlichkeit zu dem Code,
den wir f√ºr die native Android-App in Compose geschrieben haben.


## Zusammenfassung

In Flutter sind Widgets entweder _stateless_ oder _stateful_.
Ein _stateful_ Widget speichert seinen Zustand in einer separaten
`State`-Klasse, die von `State` erbt. Der Zustand kann durch
`setState` ge√§ndert werden, was zu einer automatischen
Neuzeichnung des UIs f√ºhrt.

Mehr zu _stateful_ Widgets in der Flutter-Dokumentation:

- [Grundlagen zu _state management_](https://docs.flutter.dev/get-started/fundamentals/state-management)
- [API-Docs zu `StatefulWidget`](https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html)

