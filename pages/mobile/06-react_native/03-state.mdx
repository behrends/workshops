import { Callout, Tabs } from 'nextra/components';

# Zustand (state)

<Callout>
  **Dauer:** 45 Minuten

  - `state` im `TextInput` verwenden
  - Verwendung von `state` nachvollziehen
</Callout>

## Zustand in React Native

Bisher haben wir mit `props` gesehen, wie Komponenten mit 
Eigenschaften zur Laufzeit konfiguriert werden k√∂nnen. Dabei sind 
die Eigenschaften unver√§nderlich.

Wenn nun eine Komponente sich im Laufe der Zeit ver√§ndern soll,
dann brauchen wir daf√ºr eine andere M√∂glichkeit. Diese M√∂glichkeit
ist der Zustand bzw. `state`. 

Bei der Verwendung von `state` gibt es zwei Dinge zu beachten:

- `state` ist immer privat und geh√∂rt zu einer Komponente
- `state` kann sich im Laufe der Zeit ver√§ndern

Wenn sich der `state` einer Komponente ver√§ndert, dann wird die
Komponente neu gerendert. Dies geschieht automatisch und muss nicht
von uns programmiert werden. 

Standardm√§√üig ist eine Komponente in react zustandslos (_stateless_).
Wenn wir `state` verwenden wollen, dann m√ºssen wir die Komponente
mit einem sogenannten _Hook_ ausstatten, der den `state` verwaltet.
F√ºr den `state` gibt es den Hook `useState`.

<Callout type="info">
Hooks sind ein Konzept in React Native (und React), das es uns erlaubt,
Komponenten mit bestimmten Verhalten zu versehen. Hooks sind Funktionen,
die mit `use` beginnen. 

Neben `useState` gibt es noch weitere Hooks und es ist auch m√∂glich,
eigene Hooks zu schreiben.
</Callout>

Folgende Schritte sind n√∂tig, um eine Komponente mit `state` 
auszustatten:

1. Importieren des Hooks `useState` aus `react` (nicht `react-native`!)
2. Aufruf des Hooks `useState` in der Komponente, um den `state` zu
   initialisieren und eine Funktion zum √Ñndern des `state` zu erhalten.
3. Verwendung des `state` in der Komponente

## Zustand im `TextInput`

Wir ben√∂tigen nun `state` in der Komponente `NewTodo`, damit wir uns
die Eingabe eines neuen Todos im `TextInput` im Zustand ‚Äûmerken‚Äú k√∂nnen.

### Importieren des Hooks `useState`

Zun√§chst importieren wir den Hooks `useState` aus `react`:

```jsx
import { useState } from 'react'; // <-- import aus react!
import { Button, StyleSheet, TextInput, View } from 'react-native';

// Der Rest bleibt gleich
```

Der Hook `useState` steht uns nun zur Verf√ºgung und wir k√∂nnen ihn
in der Komponente `NewTodo` verwenden.

### Aufruf des Hooks `useState` zur Initialisierung des `state`

Um den `state` zu initialisieren und eine Funktion zum √Ñndern des 
`state` zu erhalten, f√ºgen wir der Komponente `NewTodo` folgenden Code
hinzu:

```jsx
import { useState } from 'react';
import { Button, StyleSheet, TextInput, View } from 'react-native';

export default function NewTodo() {
  const [todo, setTodo] = useState(''); // <-- state mit '' initialisieren

  // Der Rest bleibt gleich
}  
```

F√ºr die Intitialisierung des `state` rufen wir `useState` auf und
√ºbergeben den initialen Wert des `state` als Argument. F√ºr den initialen
Zustand k√∂nnen wir jeden Wert verwenden, den wir wollen. In unserem Fall
ist der initiale Wert ein leerer String (ein ‚Äûleeres‚Äú Todo).

`useState` gibt uns ein Array mit zwei Elementen zur√ºck. Das erste 
Element ist die `state`-Variable mit dem aktuellen Wert des `state` 
(zun√§chst der leere String aufgrund der Intitialisierung) und das zweite 
Element ist eine Funktion, mit der wir den `state` √§ndern k√∂nnen 
(‚Äûupdate function‚Äú). Diese Funktion hei√üt in unserem Fall `setTodo` 
&mdash; wir h√§tten die Funktion und die `state`-Variabel auch anders 
nennen k√∂nnen, aber diese Art der Benennung ist √ºblich. Durch eine
Dekonstruktion des Arrays k√∂nnen wir die beiden Elemente direkt in
eine Variable und eine Funktion destrukturieren:

```jsx
const [todo, setTodo] = useState('');
```

<Callout type="info">
**Live Coding:** Eventuell die Destrukturierung des Arrays erkl√§ren.

Im Videokurs wird dies alles ausf√ºhrlich gezeigt.
</Callout>

### Verwendung des `state`

Wir haben nun den `state` initialisiert und eine Funktion zum √Ñndern
des `state` erhalten. Nun k√∂nnen wir den `state` in der Komponente
verwenden. Dazu ersetzen wir den bisherigen Wert des `TextInput` durch
den `state`:

```jsx
export default function NewTodo() {
  const [todo, setTodo] = useState('');

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Neues Todo"
        value={todo} // <-- Verwendung des state
        onChangeText={setTodo} // <-- Verwendung der update function
      />
      <Button title="Speichern" onPress={() => alert(todo)} />
    </View>
  );
}
```

Wir verwenden den `state` nun als Wert des `TextInput` und die
`setTodo`-Funktion als `onChangeText`-Handler. Wenn wir nun etwas in
das `TextInput` eingeben, dann wird der `state` aktualisiert und das
`TextInput` zeigt den aktuellen Wert des `state` an.

Au√üerdem haben wir den Aufruf von `alert` beim `Button` angepasst,
um den aktuellen Wert des `state` in der `state`-Variable anzuzeigen.

<Callout type="info">
Jede √Ñnderung des `state` f√ºhrt zu einer Neudarstellung der Komponente,
d.h. die Komponente wird neu ‚Äûgerendert‚Äú. Dies geschieht automatisch und
muss nicht von uns programmiert werden.
</Callout>

<Callout type="error" emoji="‚ÄºÔ∏è">
**Achtung:** Die √Ñnderung des `state` erfolgt **immer** mit der
√Ñnderungsfunktion (bei uns `setTodo`). Wenn wir den `state` direkt 
durch eine Zuweisung √§ndern (z.B. `todo = 'wrong!!!'`), dann wird 
die Komponente nicht neu gerendert und der `state` wird nicht aktualisiert.

Der `state` ist immer privat und geh√∂rt zu einer Komponente.
Wenn wir den `state` in einer anderen Komponente verwenden wollen, dann  
m√ºssen wir den `state` in die √ºbergeordnete Komponente verschieben und
von dort an die untergeordnete Komponente weitergeben. Dies geschieht
mit `props`, die wir in der √ºbergeordneten Komponente an die untergeordnete
Komponente √ºbergeben.
</Callout>

## √úbung: Z√§hler

Wenn gen√ºgend Zeit vorhanden ist, dann k√∂nnten wir in dem 
Standardbeispiel wir in [Expo Snack](https://snack.expo.dev)
einen Z√§hler programmieren:

![Z√§hler](/images/mobile/reactnative/counter.png)

Hierzu kann direkt in `App.js` eine `Text`-Komponente mit einem
`Button` und einem `state` programmiert werden. Der `state` ist
eine Zahl, die bei jedem Klick auf den `Button` um eins erh√∂ht wird.

<Callout type="info">
Eventuell den Anfang gemeinsam und dann weitere Buttons hinzuf√ºgen 
(z.B. um 10 erh√∂hen, auf 0 zur√ºcksetzen, usw.).
</Callout>

Ein weiterer `state` k√∂nnte die Schrittweite sein, die in einem `TextInput` 
definiert wird, das nur Zahlen als Eingabe akzeptiert. Dieser Wert wird dann beim
Antippen des Buttons zum Erh√∂hen des Z√§hlers verwendet. 

<Tabs items={['L√∂sung:', 'üëá']}>
  <Tabs.Tab>üëâ</Tabs.Tab>
  <Tabs.Tab>
  ```jsx
import {useState} from 'react';
import { Button, Text, TextInput, SafeAreaView, StyleSheet } from 'react-native';

export default function App() {
  const [counter,setCounter] = useState(0);
  const [increment,setIncrement] = useState(1);
  return (
    <SafeAreaView style={styles.container}>
      <Text style={styles.paragraph}>
        {counter}
      </Text>
      <TextInput value={increment} onChangeText={(num)=>setIncrement(+num)} keyboardType='numeric'/>
      <Button title="Z√§hlen" onPress={() =>setCounter(counter+increment) }/>
      <Button title="Um 10 erh√∂hen" onPress={() =>setCounter(counter+10) }/>
      <Button title="Auf 0 zur√ºcksetzen" onPress={() =>setCounter(0) }/>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ecf0f1',
    padding: 8,
  },
  paragraph: {
    margin: 24,
    fontSize: 128,
    color: 'orange',
    textAlign: 'center',
  },
});
  ```
  </Tabs.Tab>
</Tabs>
