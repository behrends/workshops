import Callout from 'nextra-theme-docs/callout'

# Vererbung in Klassen

<Callout>  
  **Dauer:** 35 Minuten

  - Subklassen mit `extends` deklarieren
  - Eigenschaften und Methoden werden an Subklassen vererbt

  **Ziel:** Klassenhierarchien und Vererbung zur Code-Strukturierung
</Callout>

F√ºr bestehende Klassen k√∂nnen neue Subklassen 
(Unterklassen) eingef√ºhrt werden. Dadurch
ist es m√∂glich, einerseits Unterschiede in 
√§hnlichen Klassen auszudr√ºcken und andererseits
die Gemeinsamkeiten (Instanzvariablen und Methoden)
an Subklassen zur Wiederverwendung zu ‚Äûvererben‚Äú.

![Klassenhierarchie](/images/prog/class_hierarchy.png)

Angenommen es gibt eine Klasse `Person`:

```js
class Person {
  #name;

  constructor(name) {
    this.#name = name;
  }

  getInfo() {
    return 'This is ' + this.#name;
  }
}
```

## Subklassen mit `extends` definieren

Nun wird eine neue Klasse `Student` ben√∂tigt,
die im Prinzip eine `Person` ist aber zus√§tzlich 
zum Namen auch eine Matrikelnummer haben soll.

Dies kann durch eine Subklasse `Student` von
`Person` durch das Schl√ºsselwort `extends`
erreicht werden:

```js
class Student extends Person {
  // private Instanzvariable f√ºr die Matrikelnummer
  #matNr; 
}
```

Die Subklasse `Student` **erbt** von der Klasse 
`Person` und ‚Äûerweitert‚Äú (`extends`) diese mit 
einer Instanzvariablen `matNr`. 

## Konstruktoren mit `super()`

Wenn eine Subklasse einen Konstruktor hat,
dann wird dieser in der Regel den Konstruktur
der Superklasse aufrufen &mdash; insbesondere
wenn dadurch private Instanzvariablen 
initialisiert werden sollen. Dies wird durch
das Schl√ºsselwort `super` erm√∂glicht.

Im Konstruktor der Subklasse muss als erste 
Anweisung `super(‚Ä¶)` mit den passenden Argumenten 
f√ºr den Konstruktor der Superklasse aufgerufen 
werden:

```js
class Person {
  #name;
	
  constructor(name) {
    this.#name = name;
  }

  getInfo() {
    return 'This is ' + this.#name;
  }
}
	
class Student extends Person {
  #matNr;
	
  constructor(name, matNr) {
    // Konstruktor der Superklasse aufrufen
    // dadurch werden private Instanzvariablen
    // im Konstruktor der Superklasse initialisiert
    // (diese sind in der Subklasse nicht zug√§nglich)
    // --> super muss die erste Anweisung im Konstruktor sein!
    super(name); 
	
    // danach k√∂nnen die Instanzvariablen der
    // Subklasse zugewiesen werden
    this.#matNr = matNr;
  }
}
	
// Erstelle ein Student-Objekt:
const alice = new Student('Alice', 1449382);
```

Bemerkungen zu Konstruktoraufrufen:

- `super()` muss die erste Anweisung im Konstruktor sein. 
- `super()` muss mit Argumenten passend zu der Deklaration in der Superklasse aufgerufen werden (bzw. `super()` wenn es keine Argumente im Konstruktor der Superklasse gibt).
- Mit `super()` wird (im Gegensatz zu `new ‚Ä¶`) kein neues Objekt erzeugt, sondern lediglich der Code im Rumpf des anderen Konstruktors ausgef√ºhrt.
- Konstruktoren haben keinen `return`-Ausdruck sondern erzeugen das Objekt automatisch. 

## Aufruf von Methoden der Superklasse

 Mit `super.methodenName()` lassen sich Methoden 
 der Superklasse aufrufen und somit wiederverwenden:

 ```js
class Person {
  #name;
	
  constructor(name) {
    this.#name = name;
  }

  getInfo() {	
    return 'Name: ' + this.#name;	
  }	
}
	
class Student extends Person {	
  #matNr;
	
  constructor(name, matNr) {
    super(name); 
    this.#matNr = matNr;
  }
	
  getInfo() {	
    return super.getInfo() + ' - matNr: ' + this.#matNr;
  }
}
```

Die Methode `getInfo()` ist durch √úberschreiben 
**polymorph** geworden &mdash; sie verh√§lt sich 
nun f√ºr Student anders als f√ºr Person.

<Callout type="warning" emoji="üë®üèª‚Äçüíª">
Beispiel in replit.com: 
https://replit.com/@behrends/ClassesInheritance 
</Callout>

Neben der Klasse `Student` w√§ren z.B. an einer 
Hochschule wie der DHBW weitere Subklassen
von `Person` in einer Klassenhierarchie denkbar:

![Klassenhierarchie Personen](/images/prog/person_hierarchy.png)

## Ausblick: Abstrakte Klassen und Interfaces

Oft gibt es f√ºr Superklassen keine ‚Äûechten‚Äú 
Objekte (z.B. sind alle konkreten Personen 
entweder Studierende oder Dozierende).

&xrarr; Mit abstrakten Klassen kann verhindert 
werden, dass Objekte durch eine allgemeine Klasse 
instanziiert werden, aber dennoch kann Code 
zusammengefasst und vererbt werden. 

&xrarr; Im Beispiel oben k√∂nnte `Person` 
eigentlich eine abstrakte Klasse sein.

Klassen k√∂nnen in JavaScript (und vielen anderen 
Sprachen) nur von h√∂chstens einer Superklasse erben.

&xrarr; Mit Interfaces (manchmal auch Protocols 
genannt) lassen sich weitere Datenstrukturen 
definieren, mit denen Klassen ‚Äûmehrfach erweitert‚Äú 
werden k√∂nnen, indem Klassen diese Interfaces und 
deren Methoden implementieren. 

In JavaScript gibt es diese Konzepte (noch?) nicht,
daf√ºr aber in TypeScript.

<Callout type="warning">
Interfaces, abstrakte Klassen und weitere Konzepte der Objektorientierung gibt es in TypeScript.
</Callout>
