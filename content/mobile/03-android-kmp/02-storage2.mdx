import { Callout } from 'nextra/components'

# Verwendung von Room

<Callout>
  **Dauer:** 45 Minuten

  - Room-Datenbank erstellen
  - Verwendung der Room-Datenbank in der Todo-App

  **Ziel:** Datenbankzugriff mit Room in Android verstehen
</Callout>


<Callout type="error" emoji="üö®">
Es gibt scheinbar keinen ‚ÄûBest Practice‚Äú-Weg, wie Room in einer
Compose-App eingesetzt wird. In der Android-Dokumentation, in Codelabs und in Blog-Beitr√§gen werden unterschiedliche Ans√§tze vorgestellt (Repository, Factory, Application, usw.).

Wir verwenden hier einen einfachen Ansatz, um m√∂glichst schnell und mit wenigen zus√§tzlichen Konzepten zu arbeiten. Dabei werden sicherlich einige Best Practices vernachl√§ssigt.
</Callout>


## Room-Datenbank erstellen

Wir erstellen eine abstrakte Klasse `data/AppDatabase`, die die 
Datenbank konfiguriert:

```kotlin
import androidx.room.Database
import androidx.room.RoomDatabase

@Database(entities = [Todo::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun todoDao(): TodoDao
}
```

Diese Klasse werden wir gleich verwenden, aber zun√§chst
passen wir unser ViewModel an, damit es mit der Datenbank
arbeiten kann.

## ViewModel an Room via `TodoDao` anbinden

Unser ViewModel muss wie folgt angepasst werden:

```kotlin
class TodosViewModel(private val dao: TodoDao) : ViewModel() {
    private val _todos = mutableStateListOf<Todo>()
    val todos: List<Todo> get() = _todos 

    init {
        viewModelScope.launch {
            dao.getAllTodos().collect { list ->
                _todos.clear()
                _todos.addAll(list)
            }
        }
    }

    fun add(text: String) = viewModelScope.launch {
        val t = text.trim()
        if (t.isNotEmpty()) {
            dao.insertTodo(Todo(text = t))
        }
    }

    fun toggleAt(id: Long) = viewModelScope.launch {
        val current = _todos.firstOrNull { it.id == id } ?: return@launch
        dao.updateTodo(current.copy(done = !current.done))
    }
}
```

<Callout type="important">
Wir verzichten hier auf eine Beschreibung der √Ñnderungen,
die neue Konzepte mit sich bringen (Coroutines, `viewModelScope`, `collect`, usw.).  Hier kann ein KI-Tool helfen.

Das Ziel ist, in der App ein Beispiel f√ºr die grundlegende Datenbanknutzung mit Room einzuf√ºhren. Bei Bedarf sind 
eigene Recherchen zu den neuen Konzepten notwendig.
</Callout>

## Datenbankinstanz initialisieren

Wir initialisieren die Room-Datenbank in der `MainActivity`:

```kotlin {2-15,21,27}
class MainActivity : ComponentActivity() {
    // eine DB-Instanz pro Prozess
    private val db by lazy {
        Room.databaseBuilder(
            applicationContext,
            AppDatabase::class.java,
            "todo-database"
        ).build()
    }

    private val vm: TodosViewModel by viewModels {
        viewModelFactory {
            initializer { TodosViewModel(db.todoDao()) }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            TodosApp(vm)
        }
    }
}

@Composable
fun TodosApp(vm: TodosViewModel) {
    // der Rest bleibt vorerst unver√§ndert
}
```

**Auch hier erkl√§ren wir nicht alle neuen Konzepte.**

Eine wichtige √Ñnderung ist, dass wir nun das ViewModel manuell erstellen und
an die `TodosApp` weiterreichen. 

## `TodoList` umstellen

Schlie√ülich m√ºssen wir noch die `TodoList` anpassen, damit
die Prim√§rschl√ºssel-ID eines Todos in der Liste verwendet wird:

```kotlin
@Composable
fun TodoList(todos: List<Todo>, onToggleAt: (Long) -> Unit, modifier: Modifier = Modifier) {
    LazyColumn(modifier) {
        items(items = todos, key = { it.id }) { todo ->
            TodoItem(
                todo = todo,
                onCheckedChange = { onToggleAt(todo.id) }
            )
        }
    }
}
```

Durch die Verwendung eines ViewModels haben wir nun alle
wesentlichen Umstellungen vorgenommen, um mit Room zu arbeiten.
In unserer App sollten die Todos nun in der Datenbank 
gespeichert, aktualisiert und auch nach einem App-Neustart noch 
vorhanden sein.

## Abschlie√üende Bemerkungen

<Callout type="info">
In Android Studio kann auf die Datenbank eines Emulators im 
`Database Inspector` zugegriffen werden. Dazu `View > Tool Windows > 
App Inspection` √∂ffnen.
</Callout>

Der konzeptuelle Aufbau von Room wirkt anfangs etwas komplex
(siehe grafische Darstellung des Aufbaus von Room in der 
[Dokumentation](https://developer.android.com/training/data-storage/room#components)).

Sobald Room jedoch eingerichtet ist, k√∂nnen Datenbankoperationen
einfach und effizient durchgef√ºhrt werden. Room bietet eine
umfangreiche API, um Datenbankzugriffe zu verwalten und zu
optimieren.

<Callout type="important">
In der Android-Dokumentation, in Codelabs und in Sample-Apps
finden sich viele verschiedene Ans√§tze, wie Room eingesetzt wird. Auch KI-Tools liefern unterschiedliche Antworten und Varianten. 

**Tipp:** Aus einer aktuellen Sample-App von Google den Code
nachvollziehen (ggf. mit KI erkl√§ren lassen), √ºbernehmen und an die eigenen Bed√ºrfnisse anpassen.
</Callout>

## Vertiefendes Material

Guide in Android Developer Docs zum Thema Daten und Dateien
https://developer.android.com/guide/topics/data


Room in den Android Developer Docs:

<Callout type="warning">
**Achtung**

Room entwickelt sich st√§ndig weiter‚Ä¶ (wie alles andere in Android‚Ä¶)

- [Guide](https://developer.android.com/training/data-storage/room)
- [Release Notes mit Neuigkeiten](https://developer.android.com/jetpack/androidx/releases/room)
- In den [Android Courses](https://developer.android.com/courses/) gibt es Abschnitte zu Room
- [Codelab](https://developer.android.com/codelabs/basic-android-kotlin-compose-persisting-data-room)
- [Ein paar der Code-Samples verwenden Room](https://github.com/android/compose-samples)
</Callout>

## PAUSE 

Pause an passender Stelle einlegen.

Es kann zwischendurch immer wieder Fragen geben und Bedarf f√ºr Hilfestellung geben.