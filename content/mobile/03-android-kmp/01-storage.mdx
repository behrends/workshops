import { Callout } from 'nextra/components'

# Datenbank mit Room verwalten

<Callout>
  **Dauer:** 45 Minuten

  - Abhängigkeiten hinzufügen
  - DAO (Data Access Object) erstellen

  **Ziel:** Einstieg in die Datenpersistenz mit Room
</Callout>

Wir haben bereits eine einfache Todo-App erstellt, die Todos anzeigt. Dabei haben wir bereits einige Punkte in unserem Vorgehen abgehakt:

<Callout type="info">
**Vorstellung des Frameworks**

- [x] Installation und Einrichtung der Entwicklungsumgebung
- [x] Prinzipien des Frameworks (Projektstruktur, Komponenten/Widgets, …)
- [x] App mit einem Screen: UI-Elemente, Layout, Interaktion und State
- [ ] Daten lokal speichern
- [ ] Navigation zwischen mehreren Screens

</Callout>

In Android können Daten auf dem Gerät in SQLite gespeichert werden.
Dazu gibt es die Bibliothek 
[Room](https://developer.android.com/training/data-storage/room), die 
eine umfangreiche API bereitstellt, um Daten via SQL auf dem 
Android-Gerät zu speichern. Room ist ein ORM (Object-Relational Mapping)
Framework, das die SQLite-Datenbank kapselt und den Zugriff auf die
Datenbank vereinfacht. Room nutzt Annotationen und Code-Generierung, um 
die Datenbank-Interaktionen zu optimieren und die Entwicklung zu erleichtern.

<Callout>
Parallel zu den folgenden Schritten kann die Dokumentation herangezogen werden:

https://developer.android.com/training/data-storage/room

Dort wird Room allgemeiner mit einem grafischen Überblick erklärt.

Am Whiteboard können wir die Architektur von Room am Beispiel 
der konkreten Klassen unserer TodoApp skizzieren (`TodoDao` usw.).
</Callout>

Die folgenden Änderungen im Code können auch durch dieses Codelab 
nachvollzogen werden: 
https://developer.android.com/codelabs/basic-android-kotlin-compose-persisting-data-room

**Vorbemerkung:** Der Dozent hat die Schritte mit Hilfe von ChatGPT und erstellt und diese anhand **aktueller** Quellen aus der 
Android-Dokumentation (Guides, Codelabs, Code-Samples) verfiziert und
auf den neuesten Stand gebracht.

## Room-Abhängigkeiten hinzufügen

**Vorbemerkung: auf neueste Version von Room und KSP achten**

In `gradle/libs.version.toml` die neueste Version von Room und KSP 
(Kotlin Symbol Processor) eintragen. Wie in den vorigen Jahren war dies auch im Oktober 2025 nur mühsam in der Dokumentation zu finden.

Infos hierzu müssen ggf. recherchiert und aktualisiert werden. Hier ein paar nützliche Links (Stand Oktober 2025):

- Passende KSP Releases: https://github.com/google/ksp/releases
- Infos zu KSP und `build.gradle`: https://developer.android.com/build/migrate-to-ksp
- Room-Dokumentation: https://developer.android.com/training/data-storage/room

```toml
[versions]
kotlin = "2.2.20" # aktuelle Version im Oktober 2025 
# Rest bleibt unverändert
room = "2.8.1" # aktuelle Version im Oktober 2025 
ksp = "2.2.20-2.0.3" # aktuelle Version im Oktober 2025 

[libraries]
# Rest bleibt unverändert
androidx-room-compiler = { module = "androidx.room:room-compiler", version.ref = "room" }
androidx-room-runtime = { group = "androidx.room", name = "room-runtime", version.ref = "room" }

[plugins]
# Rest bleibt unverändert
ksp = { id = "com.google.devtools.ksp", version.ref = "ksp" }
```

Abhängigkeiten eintragen in `app/build.gradle` (Modulebene):

```gradle 
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.compose)
    alias(libs.plugins.ksp) # KSP-Plugin hinzufügen
}

android {
    // … bleibt unverändert
}

dependencies {
    // Rest bleibt unverändert

    // Database
    implementation(libs.androidx.room.runtime)
    ksp(libs.androidx.room.compiler)
}
```

Danach Sync in Android Studio durchführen.

<Callout type="important">
Jedes Jahr ist es mühsam die passenden Versionen und Konfigurationen zu finden. 
Die Dokumentation und Codelabs sind teilweise inkonsistent, unvollständig oder veraltet.
</Callout>

## Todo-Entity erstellen

**Vorbemerkung &rarr;** In der Dokumentation gibt es eine grafische Darstellung des Aufbaus von Room: https://developer.android.com/training/data-storage/room#components

Wir haben bereits eine Datenklasse `Todo`, die ein konkretes Todo beschreibt. Nun bereiten wir diese Klasse so vor, dass sie von Room als _Entity_ verwendet werden kann. Eine Instanz
der Klasse `Todo` entspricht dann einer Zeile bzw. Datensatz in der Datenbank-Tabelle.

```kotlin
import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "todos")
data class Todo(
    @PrimaryKey(autoGenerate = true) val id: Long = 0L,
    val text: String,
    val done: Boolean = false
)
```

Ein Todo erhält hier als Primärschlüssel eine `id`, die automatisch von der Datenbank generiert wird.

Room als ORM kümmert sich darum, dass die Daten eines Todos in der Datenbank-Tabelle `todos` gespeichert wird. Auch die Erstellung der Tabelle in SQLite wird von Room übernommen.

Zu den Annotationen müssen die passend Importe mit `Alt-Enter` hinzugefügt werden.

## DAO (Data Access Object) erstellen

Wir erstellen ein Interface `db/TodoDao`, das als sogenanntes 
_data access object_ die benötigten Datenbankoperationen definiert:

```kotlin
// imports weggelassen

@Dao
interface TodoDao {
    @Query("SELECT * FROM todos")
    fun getAllTodos(): Flow<List<Todo>>

    @Insert
    suspend fun insertTodo(todo: Todo)

    @Update
    suspend fun updateTodo(todo: Todo)

    @Delete
    suspend fun deleteTodo(todo: Todo)
}
```

Neben den Standard-Methoden `insert`, `update` und `delete` gibt es hier
eine Methode `getAllTodos`, die alle Todos aus der Datenbank abruft.
Weitere Methoden können später bei Bedarf hinzugefügt werden, z.B. um 
Todos nach bestimmten Kriterien zu filtern.

[Kotlin Flow](https://developer.android.com/kotlin/flow) wird 
verwendet, um die Daten asynchron zu laden.

