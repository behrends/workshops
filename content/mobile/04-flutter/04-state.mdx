import { Callout } from 'nextra/components'

# Widgets mit State

<Callout>
  **Dauer:** 50 Minuten

  - `stateful` Widgets
  - Interaktion mit dem Zustand durch `setState`
  - Zustände in `MyHomePage` und `TodoItem` implementieren

  **Ziel:** Widgets und State in Flutter verstehen
</Callout>

<Callout type="info">
**Vorstellung des Frameworks**

- [x] Installation und Einrichtung der Entwicklungsumgebung
- [x] Prinzipien des Frameworks (Projektstruktur, Komponenten/Widgets, …)
- [ ] App mit einem Screen: UI-Elemente, Layout, Interaktion und State
- [ ] Daten lokal speichern
- [ ] Navigation zwischen mehreren Screens

</Callout>

In Android hatten wir es mit Composables zu tun, in Flutter 
heißen die UI-Komponenten _Widgets_. Während in Compose einzelne
Composable-Funktionen mehrere Zustandsobjekte haben können, sind 
in Flutter die Widgets durch die Klassenhierarchie als Ganzes 
_stateless_ oder _stateful_. Trotz dieses Unterschieds gibt es viele 
Parallelen zwischen den beiden Frameworks. So führt in beiden Ansätzen 
eine Änderung des Zustands zu einer automatischen Aktualisierung des UIs.

## Stateful Widgets

Ein _stateful_ Widget ist eine Klasse, die von `StatefulWidget`
erbt und die Methode `createState` implementiert. Da ein stateful 
Widget selbst unveränderlich ist, speichert es veränderlichen Zustand 
in einer separaten Klasse, die eine Subklasse von `State` ist. 
Diese `State`-Klasse wird im stateful Widget von der Methode 
`createState` zurückgegeben. 

Ein _stateful_ Widget ist eine Klasse, die von `StatefulWidget` erbt und 
`createState()` implementiert. Das Widget selbst ist unveränderlich;
veränderlicher Zustand liegt in einer separaten `State`-Subklasse, die 
`createState()` als `State<MyWidget>` zurückgibt. Die UI wird in der 
`State`-Klasse (nicht im `StatefulWidget`) in `build()` aufgebaut; Änderungen 
an der Darstellung löst man über `setState()` in der `State`-Klasse aus.

Wir bauen `TodoItem` als _stateful_ Widget um:

**Achtung:** Wir können die `build`-Methode zunächst auskommentieren,
denn diese wird gleich in den `State` verschoben.

```dart {1,6,8-14}
class TodoItem extends StatefulWidget {
  final String title;
  const TodoItem({super.key, required this.title});

  @override
  State<TodoItem> createState() => _TodoItemState();

  // Achtung: build-Methode gehört nun in den State!
  // vorübergehend auskommentiert:
  /* @override
  Widget build(BuildContext context) {
    // Rest des Codes bleibt unverändert
  }
  */
}
```

Die Methode `createState()` wird einmal beim Einfügen des Widgets 
in den UI-Baum aufgerufen und liefert eine Instanz von `State<MyWidget>`, 
die den veränderlichen Zustand verwaltet. `StatefulWidget` selbst hat 
keine `build()`-Methode; die UI wird in der `State`-Klasse über `build()`
aufgebaut. Auf die aktuelle Widget-Konfiguration greifen wir in `State` über 
`widget` zu (z.B. bei uns `widget.title`). Dazu implementieren wir unterhalb 
von `TodoItem` die Klasse `_TodoItemState`, die von `State<TodoItem>` erbt:

**Achtung:** Wir können die `build`-Methode nun in die 
`_TodoItemState`-Klasse verschieben, müssen aber im `Text`-Widget
auf `widget.title` zugreifen (anstatt nur `title` wie zuvor).

```dart {11-29}
import 'package:flutter/material.dart';

class TodoItem extends StatefulWidget {
  final String title;
  const TodoItem({super.key, required this.title});

  @override
  State<TodoItem> createState() => _TodoItemState();
}

class _TodoItemState extends State<TodoItem> {
  @override
  Widget build(BuildContext context) {
    final textStyle = Theme.of(context).textTheme.bodyLarge;
    return CheckboxListTile(
      value: false,
      onChanged: (bool? value) {
        /* to be implemented */
      },
      title: Text(
        widget.title, // Achtung: Zugriff auf widget.title!
        style: textStyle,
        maxLines: 2,
        overflow: TextOverflow.ellipsis,
      ),
      controlAffinity: ListTileControlAffinity.leading,
    );
  }
}
```

Es ist üblich, den Zustand in einer separaten Klasse zu
speichern, die mit einem Unterstrich beginnt und den Zusatz `State`
im Namen trägt. Der führende Unterstrich `_` macht die State-Klasse 
library-private In unserem Fall ist dies `_TodoItemState`. Der 
Zustand kann dann in der `State`-Klasse verwaltet werden.

## Interaktion mit dem Zustand durch `setState`

Das `State`-Objekt kann den Zustand des Widgets ändern, indem es
die Methode `setState` aufruft. Diese Methode nimmt eine Funktion
als Argument, die den neuen Zustand berechnet. In unserem Beispiel
wollen wir die Checkbox-Interaktion und das Antippen des Todos 
implementieren, um den Zustand des `TodoItem` zu ändern. 

Zunächst fügen wir im `_TodoItemState` eine `_done`-Instanzvariable vom 
Typ `bool` hinzu, die den Zustand des Todos repräsentiert:

```dart {2}
class _TodoItemState extends State<TodoItem> {
  bool _done = false; // Instanzvariable für den Zustand

  // restlicher Code bleibt unverändert
}
```

Nun können wir den Handler für die Interaktionen implementieren,
dies ist `onChanged` in der `CheckboxListTile`. Mit der `setState`-Methode
können wir den Zustand des Todos ändern:

```dart
setState(() {
  _done = !_done;
});
```

`setState` wird mit einer Funktion aufgerufen, die den neuen Zustand
berechnet. In unserem Fall wird `_done` auf den negierten Wert von
`_done` gesetzt. Das führt dazu, dass der Zustand des Todos umgekehrt
wird, wenn die `CheckboxListTile` angetippt wird. 

Außerdem müssen wir den aktuellen Wert der `CheckboxListTile` (`value`) 
auf den des Zustands `_done` setzen. 

Hier der relevante Code des `_TodoItemState`:

```dart {2,8-13}
class _TodoItemState extends State<TodoItem> {
  bool _done = false; // Instanzvariable für den Zustand

  @override
  Widget build(BuildContext context) {
    final textStyle = Theme.of(context).textTheme.bodyLarge;
    return CheckboxListTile(
      value: _done,
      onChanged: (bool? value) {
        setState(() {
          _done = !_done; // Zustand umkehren
        });
      },
      // ... restlicher Code ...
    );
  }
}
```

Die Änderung des Zustands bzw. der Aufruf von `setState` führt
zu einer **automatischen** Neuzeichnung des UIs &mdash; ganz ähnlich
wie in der nativen Android-Entwicklung mit Composables. 


## Wiederverwendbarkeit und Datenfluss nach außen.

Ähnlich wie das _state hoisting_ in Android mit Compose heißt es in Flutter 
_lifting state up_: Das Child meldet Änderungen per Callback (z. B. 
`onChanged`) nach oben; der Parent hält die Single Source of Truth, 
aktualisiert/speichert/synchronisiert das Modell. Das erhöht 
Wiederverwendbarkeit und Testbarkeit und sorgt in Listen (Reorder/Animated)
für robuste Updates ohne lokalen State-Verlust.

Als Vorbereitung für die TodoListe bauen wir im `State` auch
`initState` und `didUpdateWidget`ein:

```dart {5-13,20-34,42-44}
import 'package:flutter/material.dart';

class TodoItem extends StatefulWidget {
  final String title;
  final bool initialDone;
  final ValueChanged<bool>? onChanged;

  const TodoItem({
    super.key,
    required this.title,
    this.initialDone = false,
    this.onChanged,
  });

  @override
  State<TodoItem> createState() => _TodoItemState();
}

class _TodoItemState extends State<TodoItem> {
  late bool _done;

  @override
  void initState() {
    super.initState();
    _done = widget.initialDone;
  }

  @override
  void didUpdateWidget(covariant TodoItem oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.initialDone != widget.initialDone) {
     _done = widget.initialDone; // kein setState nötig
    }
  }

  @override
  Widget build(BuildContext context) {
    final textStyle = Theme.of(context).textTheme.bodyLarge;
    return CheckboxListTile(
      value: _done,
      onChanged: (v) {
        if (v == null) return;
        setState(() => _done = v);
        widget.onChanged?.call(v);
      },
      // Rest des Codes bleibt unverändert
    );
  }
}
```

## `MyHomePage` in stateful Widget umwandeln

Wir wandeln nun `MyHomePage` in ein _stateful_ Widget um, weil 
wir dort die Todo-Liste als Zustand verwalten wollen.

<Callout>
In VS Code gibt es einen Shortcut, um ein Widget
in ein _stateful_ Widget umzuwandeln:

Cursor auf den Klassennamen setzen und dann `Ctrl + .` (Windows/Linux) 
oder `Cmd + . (Mac)` drücken, sodass passende Code-Aktionen angezeigt
werden. Dort `Convert to StatefulWidget` auswählen.

(Die klappt wohl auch in Android Studio mit `Alt + Enter`)
Android Studio / IntelliJ IDEA: Platzieren Sie den Cursor auf dem 
</Callout>

Der angepasste Code von `MyHomePage` und der neuen State-Klasse 
`_MyHomePageState` sieht dann so aus:

```dart {1,4-5,8-23}
class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key});

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Todo-App')),
      body: const TodoList(),
      floatingActionButton: FloatingActionButton(
        onPressed: () => debugPrint('Todo hinzufügen'),
        tooltip: 'Todo hinzufügen',
        child: const Icon(Icons.add),
      ),
    );
  }
}
```

## TodoList-Zustand verwalten

Wir erweitern die neue State-Klasse `_MyHomePageState` mit einer
Instanzvariable `_todos` vom Typ `List<TodoItem>`, um die Todos
zu speichern und der `onPressed`-Handler des `FloatingActionButton`
fügt ein neues Todo hinzu: 

```dart {2,12-16}
class _MyHomePageState extends State<MyHomePage> {
  final List<TodoItem> _todos = []; // State für die Todo-Liste

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Todo-App'),
      ),
      body: const TodoList(),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          setState(() {
            _todos.add(const TodoItem(title: 'Neues Todo'));
          });
        },
        tooltip: 'Todo hinzufügen',
        child: const Icon(Icons.add),
      ),
    );
  }
}
```

Zunächst wird stets das gleiche Todo hinzugefügt (`'Neues Todo'`),
aber später verwenden wir eine Texteingabe, um den Titel des
neuen Todos zu bestimmen.

Eine Anpassung fehlt noch: Wir müssen die `TodoList`-Instanz
mit den Todos aus `_todos` initialisieren. Dazu fügen wir dem
Konstruktor von `TodoList` ein Argument `todos` hinzu. Es werden
folgende Änderungen in `TodoList` vorgenommen:

```dart {2,4-5,9-14}
class TodoList extends StatelessWidget {
  final List<TodoItem> todos;

  // der Konstruktor erhält ein Argument für die Todos
  const TodoList({super.key, required this.todos});

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: todos.length,
      itemBuilder: (context, index) {
        return todos[index];
      },
    );
  }
}
```

Hier verwenden wir nun die `todos`-Instanzvariable im `ListView.builder`,
um die Todos zu rendern, was insbesondere dann benötigt wird, wenn
die Todo-Liste dynamisch ist. Mehr zu `ListView` in der Dokumentation:
[API-Docs zu `ListView`](https://api.flutter.dev/flutter/widgets/ListView-class.html)

Nun können wir in `_MyHomePageState` die `TodoList`-Instanz mit den
Todos initialisieren:

```dart
body: TodoList(todos: _todos),
```

Nochmals der gesamte Code von `_MyHomePageState` mit der 
hervorgehobenen Änderung in `body`:

```dart {10}
class _MyHomePageState extends State<MyHomePage> {
  final List<TodoItem> _todos = [];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Todo-App'),
      ),
      body: TodoList(todos: _todos), // Todos an TodoList übergeben
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          setState(() {
            _todos.add(const TodoItem(title: 'Neues Todo'));
          });
        },
        tooltip: 'Todo hinzufügen',
        child: const Icon(Icons.add),
      ),
    );
  }
}
```

## `AlertDialog` für neue Todos

Zum Hinzufügen von neuen Todos können wir ein `AlertDialog` verwenden,
das eine Texteingabe für den Titel des neuen Todos enthält. Dazu
müssen wir den `onPressed`-Handler des `FloatingActionButton`s anpassen:

```dart
onPressed: () {
  showDialog(
    context: context,
    builder: (context) {
      final TextEditingController controller = TextEditingController();
      return AlertDialog(
        title: const Text('Neues Todo'),
        content: TextField(
          controller: controller,
          decoration: const InputDecoration(hintText: 'Todo eingeben'),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Abbrechen'),
          ),
          TextButton(
            onPressed: () {
              if (controller.text.trim().isNotEmpty) {
                Navigator.of(context).pop(controller.text.trim());
              }
            },
            child: const Text('Hinzufügen'),
          ),
        ],
      );
    },
  ).then((value) { // Fügen wir das neue Todo dem State hinzu
    if (value != null && value is String) {
      setState(() {
        _todos.add(TodoItem(title: value));
      });
    }
  });
},
```

Wir führen zusätzliche Validierung durch, um leere Todos zu vermeiden.

Auch hier haben wir wieder eine starke Ähnlichkeit zu dem Code,
den wir für die native Android-App in Compose geschrieben haben.


## Zusammenfassung

In Flutter sind Widgets entweder _stateless_ oder _stateful_.
Ein _stateful_ Widget speichert seinen Zustand in einer separaten
`State`-Klasse, die von `State` erbt. Der Zustand kann durch
`setState` geändert werden, was zu einer automatischen
Neuzeichnung des UIs führt.

Mehr zu _stateful_ Widgets in der Flutter-Dokumentation:

- [Grundlagen zu _state management_](https://docs.flutter.dev/get-started/fundamentals/state-management)
- [API-Docs zu `StatefulWidget`](https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html)

