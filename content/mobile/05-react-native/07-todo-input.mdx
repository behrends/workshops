import { Callout, Tabs } from 'nextra/components';

# Eingabe mit TextInput

<Callout>
  **Dauer:** 30 Minuten

  - `TextInput` f√ºr neue Todos einbinden  
  
</Callout>

## `TextInput` f√ºr neue Todos einbinden  

Mit [`TextInput`](https://reactnative.dev/docs/textinput) gibt es in 
React Native eine Komponente f√ºr die Eingabe von Text. Wir bauen eine 
neue Komponente `AddTodo`, die ein `TextInput` und einen Button
enth√§lt, um ein neues Todo hinzuzuf√ºgen. Durch das Antippen des
Buttons wird das Eingabefeld `TextInput` angezeigt.

Folgende Komponente in `components/AddTodo.jsx` erstellen:

```jsx
import { useState } from 'react';
import { Button, StyleSheet, TextInput, View } from 'react-native';

export default function AddTodo() {
  const [inEditMode, setEditMode] = useState(false);
  return (
    <View style={{ marginVertical: 20, width: '80%' }}>
      {inEditMode ? (
        <TextInput
          style={styles.input}
          autoFocus
          placeholder="Neues Todo eingeben"
          returnKeyType="done"
          onSubmitEditing={() => {
            // TODO üòâ: Todo hinzuf√ºgen‚Ä¶
            setEditMode(false); // Eingabemodus verlassen
          }}
          onBlur={() => setEditMode(false)} // Abbrechen bei Fokusverlust
        />
      ) : (
        <Button
          title="Todo hinzuf√ºgen"
          onPress={() => setEditMode(true)}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  input: {
    height: 40,
    borderColor: 'lightgray',
    borderRadius: 5,
    borderWidth: 1,
    padding: 10,
  },
});
```

Die Props `autoFocus` und `placeholder` im `TextInput` sorgen daf√ºr, 
dass das Eingabefeld automatisch fokussiert wird bzw. dass ein grauer 
Hinweistext erscheint, wenn das Eingabefeld leer ist. Mit `returnKeyType="done"` 
wird die Eingabetaste der Tastatur als ‚ÄûFertig‚Äú (ggf. als Checkbox)" 
angezeigt.

`onSubmitEditing` wird aufgerufen, wenn die Eingabetaste gedr√ºckt 
wird, und `onBlur`, wenn das Eingabefeld den Fokus verliert (z.B. 
durch Antippen au√üerhalb des Eingabefelds).

<Callout type="info">
`TextInput` ist in der Regel eine kontrollierte Komponente, d.h. 
der eingegebene Text wird in einem `state` gespeichert, um z.B. 
Live-Validierungen durchzuf√ºhren oder den Text anderweitig zu 
verwenden. Wir verwenden in unserem einfachen Beispiel `TextInput` 
als unkontrollierte Komponente, d.h. der eingegebene Text wird nicht 
in einem `state` gespeichert.

`TextInput` hat viele weitere n√ºtzliche Props, siehe
https://reactnative.dev/docs/textinput#props
</Callout>

DerUmgang mit dem `state` sollten an dieser Stelle gut 
nachvollziehbar sein:

- Button antippen zeigt das `TextInput` an mit `setEditMode(true)`
- Das `TextInput` hat zwei M√∂glichkeiten, den Eingabemodus zu verlassen:
  - Eingabetaste (Fertig) dr√ºcken (`onSubmitEditing` mit `setEditMode(false)`)
  - Fokus verlieren (Antippen au√üerhalb des Eingabefelds mit `onBlur` und `setEditMode(false)`)

Die Styles sorgen daf√ºr, dass das Eingabefeld gut sichtbar und 
nutzbar ist, indem es etwas gr√∂√üer ist und einen grauen Rand hat.

Wir m√ºssen uns noch darum k√ºmmern, dass in `onSubmitEditing` das neue 
Todo tats√§chlich hinzugef√ºgt wird. Dies erledigen wir im n√§chsten 
Schritt.

## `AddTodo` in `App` einbinden

Wir stellen  `AddTodo` in `App.js` oberhalb der Todo-Liste dar,
weil dies die einfachste L√∂sung ist. Sollte `AddTodo` am
unteren Bildschirmrand dargestellt werden, dann wird die Tastatur
m√∂glicherweise die Eingabe verdecken (hierzu gibt es z.B. mit 
[`KeyboardAvoidingView`](https://reactnative.dev/docs/keyboardavoidingview) 
L√∂sungen, die aber den Rahmen dieses Workshops 
sprengen).


Folgende √Ñnderungen sind n√∂tig:

```jsx {2,8}
// App.js: AddTodo importieren
import AddTodo from './components/AddTodo';
// Rest bleibt gleich

export default function App() {
  return (
    <SafeAreaView style={styles.container}>
      <AddTodo />
      <TodoList todos={todos} />
      <StatusBar style="auto" />
    </SafeAreaView>
  );
}

// Styles bleiben gleich
```

## Todo der Liste hinzuf√ºgen

Die TodoListe wird nun um die M√∂glichkeit erweitert, ein neues Todo
hinzuzuf√ºgen, d.h. die Todos m√ºssen in einem `state` verwaltet werden.

Wir gehen wie folgt vor in `App.jsx` vor: 

- `useState` importieren
- das Array `todos` in `data` umbenennen, weil wir den Namen `todos` gleich an anderer Stelle ben√∂tigen
- Einen Zustand `todos` mit `data` initialisieren

```jsx {1,4,11}
import React, { useState } from 'react';
// Rest bleibt gleich

const data = [
  { id: 1, text: 'Einkaufen' },
  { id: 2, text: 'Sport' },
  { id: 3, text: 'React Native lernen' },
];

export default function App() { 
  const [todos, setTodos] = useState(data);
 
  export default function App() {
  return (
    <SafeAreaView style={styles.container}>
      <AddTodo />
      <TodoList todos={todos} />
      <StatusBar style="auto" />
    </SafeAreaView>
  );
}

// Styles bleiben gleich
}
```

Nun m√ºssen wir `AddTodo` mitteilen, wie ein neues Todo hinzugef√ºgt
werden soll. Hierzu √ºbergeben wir eine Funktion als Prop `onAddTodo` 
an `AddTodo`, die mit dem neuen Todo-Text aufgerufen wird:

```jsx {9-16}
// Rest bleibt gleich
export default function App() { 
  const [todos, setTodos] = useState(data);
 
  export default function App() {
  return (
    <SafeAreaView style={styles.container}>
      <AddTodo
        onAddTodo={(text) => {
          if (!text || !text.trim()) return; // leere ignorieren
          const newTodo = {
            id: todos.length + 1,
            text: text,
          };
          setTodos([...todos, newTodo]);
        }}
      {/* usw. */}
  )
}} />
```

Das neue Todo wird nur hinzugef√ºgt, wenn der Text nicht leer ist
(ggf. nur aus Leerzeichen besteht). Ein neues Todo-Objekt wird
erstellt mit einer neuen ID (einfach die L√§nge des Arrays + 1)
und dem √ºbergebenen Text. Mit `setTodos` wird der Zustand `todos`
aktualisiert, indem ein neues Array mit dem neuen Todo am Ende
erstellt wird (`...` ist der Spread-Operator in JavaScript).

Nun fehlt nur noch die Verwendung des `onAddTodo`-Props in `AddTodo`:

```jsx {2,12-17}
// Rest bleibt gleich
export default function AddTodo({ onAddTodo }) {
  const [inEditMode, setEditMode] = useState(false);
  return (
    <View style={{ marginVertical: 20, width: '80%' }}>
      {inEditMode ? (
        <TextInput
          style={styles.input}
          autoFocus
          placeholder="Neues Todo eingeben"
          returnKeyType="done"
          onSubmitEditing={({ nativeEvent: { text } }) => {
            const value = text.trim();
            if (!value) return; // leere ignorieren
            onAddTodo(value);
            setEditMode(false);
          }}
          onBlur={() => setEditMode(false)} // Abbrechen bei Fokusverlust
        />
      ) : (
        <Button
          title="Todo hinzuf√ºgen"
          onPress={() => setEditMode(true)}
        />
      )}
    </View>
  );
}

// Styles bleiben gleich
```

In `onSubmitEditing` wird der eingegebene Text aus dem Event-Objekt
entnommen (`nativeEvent.text`), getrimmt und gepr√ºft, ob er leer ist. Wenn
der Text nicht leer ist, wird die `onAddTodo`-Funktion mit dem
Text aufgerufen, um das neue Todo hinzuzuf√ºgen.

<Callout type="info">
In React Native kommt es h√§ufig vor, dass wir einen `state` in 
einem Eltern-Element verwalten und diesen dann an ein Kind-Element
√ºbergeben. Das Kind-Element kann dann den `state` nicht ver√§ndern,
sondern muss den Eltern-Element mitteilen, dass sich etwas ge√§ndert hat.
Dies geschieht √ºber eine Funktion, die wir dem Kind-Element als Prop √ºbergeben
(siehe oben im `onAddTodo`-Prop).
</Callout>
