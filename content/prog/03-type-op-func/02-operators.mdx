import { Callout } from 'nextra/components'

# Operatoren

<Callout>
  **Dauer:** 55 Minuten

  - Operatoren f√ºr Berechnungen (`+`,`-`, usw.)
  - Vergleichsoperatoren
  - logische Operatoren
  - Inkrement/Dekrement
  - Bedingungsoperator

  **Ziel:** √úberblick wichtiger Operatoren
</Callout>

Mit **Operatoren** lassen sich beliebig komplexe 
**Ausdr√ºcke** konstruieren:

```js
1.8 * 4 - (2 + 4.23)
```

F√ºr **number** (ganze Zahlen, Gleitkommazahlen) gibt es 
**arithmetische Operatoren** und **Vergleichsoperatoren**:

- Arithmetische Operatoren sind u.a. die Addition, Multiplikation,
etc.
- Vergleichsoperatoren sind z. B. kleiner (`<`), gr√∂√üer oder 
gleich (`>=`), etc.

Es gibt mehrere **einstellige** und **zweistellige** Operatoren.
(Ein Operator ist sogar dreistellig.) 

<Callout type="info">
Der Operator `typeof`, der in der Lektion zu
[Datentypen](./01-typen#typeof) besprochen wurde,
ist ein Beispiel f√ºr einen einstelligen Operator.
</Callout>

## Zweistellige numerische Operatoren

- ``+`` Addition
- ``-`` Substraktion
- ``*`` Multiplikation
- ``/`` Division
- ``%`` Rest einer Division (Modulo-Operator)
- ``**`` Exponentiation (Potenzieren)

Zweistellig hei√üt hier, dass der Operator mit zwei 
Zahlen (allgemein: **Operanden**) zu verwenden ist 
(z. B. ``op1 + op2`` bei der Addition).

```js
let i = 17 / 10;     // ==> i = ???
let j = 17 % 10;     // ==> j = ???
// ==> z. B. in der Konsole ausprobieren‚Ä¶
```

Das Ergebnis dieser Operatoren ist wiederum ein numerischer 
Wert.

Achtung: In JavaScript kann die Division eine Kommazahl ergeben. 
In anderen Programmiersprachen wie z. B. Java steht ``/`` f√ºr die
ganzzahlige Division. 

## `+` bei Strings

Mit `+` k√∂nnen zwei Strings zu einem neuen String 
zusammengesetzt werden. Dies wird als **Stringkonkatenation**
bezeichnet.

``js
let name = prompt("Wie hei√üt Du?");
console.log("Hallo, " + name + ". Wie geht es Dir?");
``

Mit Template-Strings ist es evtl. einfacher, Text 
zusammenzusetzen:

```js
let name = prompt("Wie hei√üt Du?");
console.log(`Hallo, ${name}. Wie geht es Dir?`)
```

Template-Strings wurden bereits im Abschnitt √ºber 
[Datentypen](/prog/03-type-op-func/01-typen#template-strings) 
vorgestellt.

## Vergleichsoperatoren

Bei Vergleichsoperatoren werden haupts√§chlich zwei numerische 
Werte miteinander verglichen.

Das Ergebnis ist ein Wahrheitswert vom Typ `boolean` 
(`true` oder `false`).

- `<`   kleiner
- `<=` 	kleiner oder gleich
- `>` 	gr√∂√üer
- `>=` 	gr√∂√üer oder gleich
- `===` gleich
- `!==` ungleich

Wichtig: Gleichheit sollte mit `===` bzw. Ungleichheit mit 
`!==` getestet werden. 

Der ‚Äûnormale‚Äú Test auf Gleichheit mit `==` ist in JavaScript
problematisch, denn dies kann zu unerwarteten Ergebnissen 
f√ºhren:

```js
4 == "4"; // ergibt true!
```

Hier wird beim **schwachen** Vergleich mit == eine automatische 
Typumwandlungen durchgef√ºhrt, sodass hier zwei Strings 
miteinander verglichen werden.

Daher sollte eigentlich immer der **starke** Vergleich mit 
`===` verwendet werden:

```js
4 === "4"; // ergibt nun wie gew√ºnscht false!
```

Entsprechendes gilt f√ºr den Test auf Ungleichheit mit `!==`. 

<Callout type="warning">
Beim ‚Äûschwachen‚Äú Vergleich (`==` und `!=`) wird sozusagen
nur der ‚ÄûInhalt‚Äú einer Variablen oder eines Ausdrucks 
√ºberpr√ºft, wohingegen der ‚Äûstarke‚Äú Vergleich (`===` und `!==`)
sowohl Inhalt als auch den Datentypen in den Vergleich einbezieht.
So ergibt der Vergleich mit `===` f√ºr einen Wert vom Typ `string` 
mit einem Wert vom Typ `number` grunds√§tzlich `false`, da dies
verschiedene Datentypen sind.
</Callout>

<Callout type="info">
In den meisten F√§llen ist eine Verwendung eines schwachen 
Vergleichsoperators (`==` und `!=`) unproblematisch. Dennoch
sollte aus oben genannten Gr√ºnden stets ein starker Vergleichsoperator
(`===` und `!==`) eingesetzt werden &mdash; dies ist eine bevorzugte und
empfohlene Herangehensweise (‚Äû_best practice_‚Äú) in JavaScript.
</Callout>

## Logische Operatoren

Logische Operatoren werden auf Wahrheitswerte angewendet. 
Das Ergebnis ist wiederum ein Wahrheitswert.

Folgende logischen Operatoren sind relevant:

| Operator | Beschreibung | Erl√§uterung |
|---|---|---|
| `&&` | logisches UND (zweistelliger Operator) | `true` falls beide Operanden wahr sind, sonst `false` |
| `\|\|` | logisches ODER (zweistellig) | `true` falls mind. ein Operand wahr ist, sonst `false` |
| `!` | Negation (einstellig) | `!true` ergibt `false` und umgekehrt |

```js
let x = (8 < 9) && (1 > 5); // --> false
let y = (8 < 9) || (1 > 5); // --> true
let z = !x; // --> true
```

<Callout type="info">
Wir nennen das Zeichen `&` **‚ÄûUnd-Zeichen‚Äú** und der **‚Äûsenkrechte Strich‚Äú** `|` 
wird in der Programmierung h√§ufig auf Englisch ‚Äû_pipe_‚Äú genannt.
</Callout>

**Beispiel**

```js
// Mehrfachdeklaration von drei Variablen mit Initialisierungen
let age = 23, age2 = 134, age3 = 17;

// UND: Alter eines Erwachsenen liegt zwischen 18 und 120 
age >= 18 && age < 120; // true  (beide sind true)
age2 >= 18 && age2 < 120; // false (eine ist false)

// ODER: Alter darf nicht zwischen 14 und 18 liegen
// Situation: Jugendliche d√ºrfen nicht auf den Spielplatz
age >= 18 || age < 14; // true (eine ist true)
age3 >= 18 || age3 < 14; // false (beide sind false)
```

<Callout type="info">
Die √ºbrigen logischen Operatoren wie z. B. `&` und `|` 
behandeln wir nicht. Mit diesen k√∂nnen bitweise Operationen durchgef√ºhrt werden,
wie z. B. [hier bei MDN beschrieben](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND).
</Callout>

## Besondere einstellige Operatoren

H√§ufig in `for`-Schleifen verwendete und daher wichtige 
einstellige Operatoren sind die folgenden beiden:

| Operator | Beschreibung | Erl√§uterung |
|---|---|---|
| `++` |	Inkrement |	Erh√∂hung um 1 |
| `--` |	Dekrement |	Verringerung um 1 |

Diese Operatoren sind einstellig und werden also nur auf 
einen Wert (bzw. Operanden) angewendet.

Sie werden numerischen Ausdr√ºcken vor- (Pr√§fix) oder 
nachgestellt (Postfix).

```js
let x = 4;
x++; // --> Erh√∂ht x um 1
--x; // --> Verringert x um 1
```

Der Wert der Variablen x wird ge√§ndert! \
(`++` und `--` f√ºhren entsprechende Zuweisungen aus)

Sowohl der vorangestellte Pr√§fix-Operator (`++x`) und der 
nachfolgend notierte Postfix-Operator (`x++`) erh√∂hen den 
aktuellen Wert der Variablen `x` um `1`.
Dennoch gibt es einen subtilen Unterschied in der Auswertung (Semantik)
der beiden Varianten von `++` und `--`,
wie folgendes ‚ÄûQuiz‚Äú veranschaulichen 
soll (Code in der Konsole des Browsers ausprobieren).

**Einstellige Operatoren: Quiz**

```js
let x = 8;
// Unten geben wir zuerst den Ausdruck bzw. des Ergebnis des Operators aus
// und dann wird der aktuelle Wert der Variablen ausgegeben
console.log(++x);  // Nr. 1
console.log(x);    // Nr. 2

console.log(x++);  // Nr. 3
console.log(x);    // Nr. 4

//optional: auch mit x-- und --x durchspielen
```

<Callout type="info">
Der Postfix-Operator (`x++`) wird erst
auf die Variable (hier `x`) angewendet, nachdem `x` ausgewertet wurde
, z. B. in der Ausgabe mit `console.log(x++)`. 

Der Pr√§fix-Operator (`++x`) wird 
angewendet bevor die Variable (hier `x`) 
ausgewertet wird, z. B. in der Ausgabe mit `console.log(++x)`.

In den meisten Verwendungen hat
dieser Unterschied keine Auswirkungen. 
Dennoch wird manchmal empfohlen, anstatt
`++` bzw. `--` eine ‚Äûnormale‚Äú Zuweisung
zu verwenden (`x = x + 1` bzw. `x = x - 1`).
</Callout>

<Callout type="warning">
Die Inkrement- und Dekrement-Operatoren d√ºrfen nicht mit
Konstanten verwendet werden, da diesen keine neuen Werte
zugewiesen werden d√ºrfen.
</Callout>

## Zusammengesetzte Zuweisungsoperatoren

Zun√§chst betrachten wir folgende Art von Zuweisungen: \
`a = a OP b`

`a` und `b` seien numerische Variablen und `OP` sei ein 
zweistelliger, arithmetischer Operator.

Ausgehend von dem aktuellen Wert von `a` wird der Variablen 
`a` also ein neuer Wert zugewiesen.

Solch eine Zuweisung kann wie folgt vereinfacht werden: \
`a OP= b`

Beispiele:

```js	
let x = 8, y = 9;

x += 9; // dies entspricht dem Ausdruck x = x + 9;
	
x -= 9; // dies entspricht dem Ausdruck x = x - 9;
	
x *= y; // dies entspricht dem Ausdruck x = x * y;	
// usw.
	
// diese Abk√ºrzungen sind f√ºr zweistellige Operatoren m√∂glich, wenn
// der Operator den gleichen Datentyp wie die beteiligten Werte liefert
```

Die Verwendung dieser Abk√ºrzung ist gut abzuw√§gen, denn die 
Lesbarkeit eines Programms kann sich dadurch verschlechtern.


## Bedingungsoperator (dreistellig)

In einigen Programmiersprachen und auch in JavaScript gibt es einen dreistelligen 
Operator. Mit diesem lassen sich einfache Fallunterscheidungen 
in kompakten Ausdr√ºcken formulieren (ohne `if`).

Dieser Operator hei√üt **Bedingungsoperator** und wird manchmal 
auch ‚Äû_inline-if_‚Äú oder nach seiner Dreistelligkeit ‚Äûtern√§rer Operator‚Äú genannt. Er besteht aus Fragezeichen und Doppelpunkt.

```
WAHRHEITSWERT ? ERGEBNIS_WENN_TRUE : ERGEBNIS_WENN_FALSE
```

- Der Ausdruck in `WAHRHEITSWERT` muss vom Typ `boolean` sein.
- Durch `WAHRHEITSWERT` wird also die Bedingung ausgedr√ºckt.
- F√ºr `ERGEBNIS_WENN_TRUE` und `ERGEBNIS_WENN_FALSE` sollten die gleichen Typen verwendet werden (z. B. Zahlen oder Strings)
- Das Ergebnis (`ERGEBNIS_WENN_TRUE` oder `ERGEBNIS_WENN_FALSE`) kann einer Variablen zugewiesen werden. 

Beispiel:

```js
let x = 1000;
let y = 100;
let ergebnis = x > y ? "stimmt" : "leider nicht";
```

<Callout type="info" emoji="üë®üèª‚Äçüíª">
In der gemeinsam entwickelten Wetter-App k√∂nnten wir
abh√§ngig von der Temperatur eine Meldung ausgeben,
z. B. ‚Äû_Ziemlich kalt!_‚Äú oder ‚Äû_Nicht zu kalt_‚Äú.

Dazu setzen wir einen Vergleich und den Bedingungsoperator ein. 
</Callout>

## Priorit√§ten der Operatoren

Aus der Schule kennen wir vielleicht den Merksatz
‚Äû_Punktrechnung vor Strichrechnung_‚Äú, mit dem 
ausgedr√ºckt wird, dass in einer Berechnung z. B. mit 
Multiplikation und Addition zuerst die Multiplikation
ausgef√ºhrt wird.

In Programmiersprachen gilt hierbei das gleiche.
Zus√§tzlich werden f√ºr alle Operatoren Priorit√§ten
definiert, die sich auf die Auswertung von Ausdr√ºcken
mit mehreren unterschiedlichen Operatoren auswirken.

Mehr dazu hier: 

- [Operator Precedence bei javascript.info](https://javascript.info/operators#operator-precedence)
- [Operator Precedence im Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)