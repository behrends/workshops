import { Callout } from 'nextra/components'

# Funktionen (Teil 1)

<Callout>
  **Dauer:** 60 Minuten

  - Aufbau und Verwendung von Funktionen
  - Deklaration, Parameter, R√ºckgabewerte
  - Aufruf und Verwendung von R√ºckgabewerten

  **Ziel:** Funktionen geben Programmen Struktur
</Callout>

<Callout type="info">
Wir betrachten Funktionen hier zun√§chst als M√∂glichkeit,
Anweisungen zusammenzufassen und somit Struktur im
Programm zu erhalten.

Funktionen sind ein m√§chtiges Werkzeug und wir werden
sp√§ter noch weitere Aspekte kennenlernen (z. B. Arrow-Funktionen,
Funktionen als Parameter, usw.).
</Callout>

Mit Funktionen lassen sich Teile des ausf√ºhrbaren 
Programmcodes zu ‚ÄûUnterprogrammen‚Äú zusammenfassen.

Beispiele: Einlesen von Daten (Benutzereingaben durch die 
Tastatur), Formatierung einer Ausgabe auf dem Bildschirm, 
komplexe Berechnungen, usw.

Folgendes kann mit Funktionen erreicht werden:

- Strukturierung bzw. Modularisierung des Programms, wodurch Programme leichter nachvollziehbar werden (einfachere Lesbarkeit)
- Reduzierung des Programmieraufwands (z. B. durch Wiederverwendbarkeit bestimmter Abl√§ufe)
- Anpassungen von Programmen werden erleichtert (bessere Wartbarkeit)

**Bisherige Verwendung bzw. Aufrufe von Funktionen**

Im folgenden Beispiel sind zwei Funktionsaufrufe zu sehen:

```js
import { question } from 'readline-sync';

let input = question("Bitte Namen eingeben");
console.log(input);
```

Die Funktion `question` (aus `readline-sync`) wird mit einem Text-**Parameter/-Argument**
aufgerufen und wir weisen das Ergebnis bzw. den **R√ºckgabewert**
der Funktion einer Variablen `input` zu.

Im **Aufruf** von `console.log` **√ºbergeben** wir `input` als 
*Parameter/Argument* an die Funktion.


## Grundstruktur von Funktionen

Eine Funktion kann keine bis beliebig viele Parameter 
(Argumente) haben. Eine Funktion hat **immer** einen 
R√ºckgabewert (Ergebnis) &mdash; auch ohne `return`. Allerdings kann dieser beim Aufruf der Funktion ignoriert werden (z. B. wenn keine Zuweisung des R√ºckgabewerts an eine Variable erfolgt).

![Grundstruktur von Funktionen](/images/prog/funktionen.png)

Die Parameter werden durch unterschiedliche Namen in den runden Klammern angegeben (`param1, param2, usw.`). R√ºckgabewerte werden
durch `return` meistens als letzte Zeile am Ende des
Funktionsrumpfs angegeben.

Endet die Ausf√ºhrung einer Funktion ohne `return`-Anweisung, dann 
wird `undefined` als Ergebnis der Funktion zur√ºckgeliefert.

Parameter und R√ºckgabewerte werden in JavaScript nicht mit 
Datentypen angegeben ‚Äî dies kann nahtlos durch die Erweiterung 
mit TypeScript erfolgen. 

## Deklaration einer Funktion

Betrachten wir folgendes Beispiel:

```js
function testFunction(firstParam, secondParam) {
  let x = 0;

  // Anweisungen und Berechnungen im Funktionsrumpf	
  x = 123 + firstParam + secondParam;
	
  // R√ºckgabewert - meist am Ende der Funktion
  return x;
}
```

Somit besteht die Deklaration einer Funktion aus

- Dem Schl√ºsselwort `function` gefolgt von einem Namen (oben `testFunction`)
- den beliebig vielen Parametern der Funktion, die unterschiedliche Namen haben und mit Komma voneinander getrennt werden (oben `firstParam` und `secondParam`).
- dem Funktionsrumpf zwischen `{ ‚Ä¶ }`
- optional: einer `return`-Anweisung, die das Ergebnis der Funktion zur√ºckliefert (wenn erforderlich bzw. gew√ºnscht)

Der **Funktionsrumpf** steht zwischen `{ ‚Ä¶ }` und enth√§lt Anweisungen.

Lokale Variablen k√∂nnen im Rumpf der Funktion deklariert werden, sodass dies ihr G√ºltigkeitsbereich ist,
und sie au√üerhalb der Funktion nicht existieren bzw. nicht bekannt sind. 

<Callout type="info">
Gibt es eine Variable/Konstante mit Namen `myName` au√üerhalb der Funktion,
dann kann innerhalb der Funktion eine Variable/Konstante mit gleichem Namen `myName` deklariert werden. 

<mark>Es handelt sich dann aber um zwei verschiedene Variablen mit gleichem Namen.</mark>
</Callout>

<Callout type="info">
Funktionen k√∂nnen Funktionen enthalten, d.h. es ist m√∂glich, innerhalb einer Funktion 
sozusagen eine ‚Äûlokale‚Äú Funktion zu deklarieren, die nur in dieser Funktion existiert.
</Callout>

### Aufruf einer Funktion

Der Aufruf der Funktion aus obigem Beispiel erfolgt mit 
passenden Parametern: 

```js
testFunction(15, 26);
```

**Achtung:** es d√ºrfen auch mehr oder weniger Parameter 
angegeben werden (also aufpassen!).

Beim Aufruf sollte (!) die vorgesehene Parameteranzahl mit passenden Datentypen angegeben werden.

Das Ergebnis der Funktion kann z. B. einer Variablen zugewiesen werden: 

```js
const result = testFunction(15, 26);
```

Danach steht das Ergebnis bzw. der R√ºckgabewert des 
Funktionsaufrufs in der Konstanten `result` zur weiteren
Verwendung bereit.

<Callout type="warning">
Auch wenn eine Funktionsdeklaration erst sp√§ter oder am Ende eines Skripts bzw.
der Datei steht, kann sie (Hoisting) schon zuvor aufgerufen werden:

```js
test(); // Aufruf einer Funktion...
// ... die erst ‚Äûsp√§ter‚Äú deklariert wird
function test() {
  console.log("Test!");
}
```

Das gilt nicht f√ºr Funktionsausdr√ºcke oder Arrow-Funktionen; dennoch ist es
in der Regel empfehlenswert, Funktionen am Anfang einer Datei zu deklarieren,
damit der Code √ºbersichtlicher, lesbarer und leichter nachzuvollziehen ist.
</Callout>

<Callout type="info" emoji="üë®üèª‚Äçüíª">
In der gemeinsam entwickelten Wetter-App nutzen
wir Funktionen f√ºr die Eingabe, die ‚ÄûErmittlung‚Äú und die
Ausgabe der Wetterdaten, z. B.

- `getLocation()`
- `getTemperature()`
- `displayWeather()`
</Callout>

## Ablauf des Funktionsaufrufs im Detail

Zur Veranschaulichung des Ablaufs eines Funktionsaufrufs 
soll die folgende grobe Darstellung dienen:

- Initialisiere die Parameter der Funktion mit den Werten der aktuellen Parameter wie sie beim Aufruf angegeben sind.
- F√ºhre den Rumpf der Funktion aus.
- Falls vorhanden, gib den R√ºckgabewert (Ergebniswert) zur√ºck.
- Vernichte alle lokalen Variablen und Parameter-Variablen der Funktion.

Was bedeutet dies f√ºr die Parameter?

- Die Funktion arbeitet mit Kopien der aktuellen Parameter.
- Wenn also Variablen als Parameter im Aufruf einer Funktion verwendet werden, dann √§ndern sich diese Variablen nicht durch die Anweisungen in der Funktion.
- Dies wird ‚Äû_call-by-value_" genannt, weil nur die Werte (bei Objekten: Referenzwerte) und nicht die Variablen selbst √ºbergeben werden.

<Callout type="info">
Bei Objekten als Parameter gilt eine Besonderheit: √Ñnderungen an
Eigenschaften eines Objekt-Parameters wirken sich auch au√üerhalb
der Funktion aus. Dies wird verst√§ndlicher, wenn wir sp√§ter
[Objektreferenzen](/prog/07-structure/02-object-references) behandeln.
</Callout>
